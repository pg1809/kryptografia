package pl.kryptografia.rabin.calculation;

import java.util.ArrayList;
import java.util.List;
import pl.kryptografia.rabin.bignum.BigNum;
import pl.kryptografia.rabin.bignum.BigNumPool;

/**
 *
 * @author Wojciech Sza≈Çapski
 */
public class PrimeSieve {

    /**
     * Prime numbers generator and checker.
     */
    private final static PrimeGenerator primeGenerator = PrimeGenerator.getInstance();

    /**
     * Pool used for creating temporary big integers.
     */
    private final static BigNumPool pool = BigNumPool.getInstance();
    
    /**
     * Maximum prime to be generated by Eratostenes sieve.
     */
    private final int MAX_GENERATED_PRIME = 300000;

    private final int SIEVE_SIZE = 1000;

    private final int ACCURACY = 15;

    private PrimeSieve() {
    }

    /**
     * Generates two prime number which are not greater than given odd number
     * and give the same remainder modulo 4.
     *
     * @param maximum Maximum odd number which can be generated.
     * @return A pair of big prime numbers not greater than given maximum and
     * with the same remainder modulo 4 as the maximum.
     */
    public Pair generateTwoPrimes(BigNum maximum) {
        long startTime = System.nanoTime();
        
        pool.open();
        
        // how many primes we already generated
        int primesGenerated = 0;
        // a buffer for primes we are going to find
        BigNum[] result = new BigNum[2];

        // small primes used to sieve out candidates which are not prime
        int[] smallPrimes = generateOddPrimes();
        
        // we need boxed versions of primes to use BigNum class methods
        BigNum[] boxedPrimes = new BigNum[smallPrimes.length];
        for (int i = 0; i < smallPrimes.length; ++i) {
            boxedPrimes[i] = pool.get();
            boxedPrimes[i].initializeFromInt(smallPrimes[i]);
        }

        // initial number to test (maximum tested number)
        BigNum start = new BigNum(maximum);
        // a step we move down (we need all our candidates to give the same 
        // remainder modulo 4)
        BigNum four = new BigNum(4);

        // candidates to be tested
        BigNum[] candidates = new BigNum[SIEVE_SIZE];

        // initially we are goin to assume all candidates are prime
        boolean[] isPrime = new boolean[SIEVE_SIZE];

        while (primesGenerated < 2) {
            for (int i = 0; i < SIEVE_SIZE; ++i) {
                // we put all candidates into the sieve
                // we could add 4 instead of subtracting it but we want to be
                // sure that our primes will not overflow 1/4 of the blocks
                BigNum toSubtract = new BigNum((SIEVE_SIZE - i - 1) * 4);
                candidates[i] = new BigNum(start);
                candidates[i].subtract(toSubtract);

                isPrime[i] = true;
            }

            // minimal number in the sieve is used to calculate the step in
            // sieving out complex numbers
            BigNum minimum = new BigNum(candidates[0]);

            int counter = 0;
            for (int prime : smallPrimes) {
                // the remainder of first number in the sieve modulo current 
                // small prime is used to determine which number we sieve out
                // in this step
                BigNum remainder = new BigNum(minimum);
                remainder.modulo(boxedPrimes[counter++]);

                // we calculate:
                // minimum % prime = remainder
                // we need to check if there are some k satisfying the
                // condition:
                //    (minimum + 4 * k) % prime = 0
                // unbox the remainder
                int r = (int) remainder.getBlock(BigNum.BLOCKS - 1);

                // find the smallest k which satisfy the above condition
                int currentCandidate = 0;
                while (currentCandidate < SIEVE_SIZE) {
                    if (r == 0) {
                        isPrime[currentCandidate] = false;
                        break;
                    }

                    // now we can try to skip testing some candidates
                    // remainder is less than prime
                    // with each candidate we increase the remainder by 4
                    // we can say that a candidate is complex when we get:
                    //    remainder + 4 * k = m * p
                    // where k and m are some integers
                    // we can take k equal ceil((p - r) / 4)
                    int step = (prime - r) / 4;
                    if ((prime - r) % 4 != 0) {
                        ++step;
                    }
                    
                    currentCandidate += step;
                    r += 4 * step;
                    r %= prime;
                }

                // when some candidate is divisible by current prime we can
                // disqualify some other candidates which are also divisible
                while (currentCandidate < SIEVE_SIZE) {
                    isPrime[currentCandidate] = false;
                    currentCandidate += prime;
                }
            }
            
            System.out.println("time: " + (System.nanoTime() - startTime) / 1000000);
            
            System.out.println("Sieving finished");
            int numbersToCheck = 0;
            for (int i = 0; i < SIEVE_SIZE; ++i) {
                if (isPrime[i]) {
                    ++numbersToCheck;
                }
            }

            System.out.println("Numbers to be checked: " + numbersToCheck);

            for (int i = 0; i < SIEVE_SIZE; ++i) {
                // for candidates which still can be primes we perform
                // Miller-Rabin test
                if (isPrime[i]) {
                    System.out.println("Checking");
                    if (primeGenerator.isPrime(candidates[i], ACCURACY)) {
                        // no we are almost sure the candidate is prime
                        // the chance it is complex is:
                        // 4^(-ACCURACY)
                        result[primesGenerated++] = new BigNum(candidates[i]);
                        if (primesGenerated == 2) {
                            pool.close();
                            return new Pair(result[0], result[1]);
                        }
                    }
                }
            }

            // if we still do not have two primes we take the next SIEVE_SIZE
            // number of candidates
            start = new BigNum(minimum);
            start.subtract(four);
        }

        pool.close();
        return null;
    }

    /**
     * From given array of big numbers removes all which are divisible by any of
     * given small prime numbers.
     *
     * @param smallPrimes Small primes used to sieve out complex numbers.
     * @param bignums Big numbers to be tested.
     * @return All numbers from given array that has not been qualified as
     * complex.
     */
    public List<BigNum> sieveOutComplexNumbers(int[] smallPrimes, BigNum[] bignums) {
        int count = bignums.length;

        // initially we assume all our big numbers are valid candidates for 
        // prime numbers
        boolean[] isPrime = new boolean[count];
        for (int i = 0; i < count; ++i) {
            isPrime[i] = true;
        }

        for (int prime : smallPrimes) {
            // create a big number with current prime value
            BigNum boxedPrime = new BigNum(prime);

            for (int i = 0; i < count; ++i) {
                // we do not need to check numbers which have already been
                // sieved out
                if (isPrime[i]) {
                    // check if our candidate is divisible by current small
                    // prime number
                    if (bignums[i].isDivisible(boxedPrime)) {
                        isPrime[i] = false;
                    }
                }
            }
        }

        // get all numbers which still can be prime
        List<BigNum> result = new ArrayList<>();
        for (int i = 0; i < count; ++i) {
            if (isPrime[i]) {
                result.add(bignums[i]);
            }
        }

        return result;
    }

    /**
     * Generates all odd primes not greater than MAX_GENERATED_PRIME constant.
     *
     * @return All generated odd primes in increasing order.
     */
    private int[] generateOddPrimes() {
        // array tab holds all numbers up to MAX_GENERATED_PRIME constant
        boolean tab[] = new boolean[MAX_GENERATED_PRIME + 1];

        // for each number the value in array indicates if it is a prime number
        tab[0] = false;
        tab[1] = false;
        tab[2] = true;

        // initially we assume that every odd number greater than 2 is prime
        // as algorithm iterates we sieve out complex numbers
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            tab[i] = ((i % 2) == 1);
        }

        // we only need to iterate up to square root from the maximum number
        // to sieve out all complex numbers
        // in every iteration we increase i by 2 because even numbers for sure
        // are complex
        for (int i = 3; i * i <= MAX_GENERATED_PRIME; i += 2) {
            if (tab[i]) {
                // every multiple of i must be a complex number
                for (int j = i + i; j <= MAX_GENERATED_PRIME; j += i) {
                    tab[j] = false;
                }
            }
        }

        // count all generated all primes to allocate an array of appropriate
        // size
        int primesCount = 0;
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            if (tab[i]) {
                ++primesCount;
            }
        }

        // an array for all generated odd primes
        int result[] = new int[primesCount];
        int position = 0;
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            if (tab[i]) {
                result[position] = i;
                ++position;
            }
        }

        return result;
    }

    public static PrimeSieve getInstance() {
        return PrimeSieveHolder.INSTANCE;

    }

    private static class PrimeSieveHolder {

        private static final PrimeSieve INSTANCE = new PrimeSieve();
    }
}
