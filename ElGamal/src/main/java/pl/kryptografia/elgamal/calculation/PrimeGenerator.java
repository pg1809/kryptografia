package pl.kryptografia.elgamal.calculation;

import java.util.Random;
import pl.kryptografia.elgamal.bignum.BigNum;
import pl.kryptografia.elgamal.bignum.BigNumPool;

/**
 *
 */
public class PrimeGenerator {

    /**
     * Primality tester.
     */
    private final static PrimeTester primeTester = PrimeTester.getInstance();

    /**
     * Pool used for creating temporary big integers.
     */
    private final static BigNumPool pool = BigNumPool.getInstance();

    private final static Random randomGenerator = new Random();

    /**
     * Maximum prime to be generated by Eratostenes sieve.
     */
    private final int MAX_GENERATED_PRIME = 100000;

    private final int SIEVE_SIZE = 2000;

    private final int ACCURACY = 15;

    private PrimeGenerator() {
    }

    /**
     * Generates a safe prime (p = 2 * q + 1 where q is prime) together with a
     * generator g for multiplicative group Zp.
     *
     * @param maximum Maximum q which is used in generating (must be odd).
     * @return A pair(p, g) as described above.
     */
    public Pair generateSafePrimeWithGenerator(BigNum maximum) {
        Pair safePrime = generateSafePrime(maximum);
        BigNum p = safePrime.first;
        BigNum q = safePrime.second;

        BigNum n = new BigNum(p);
        n.subtract(BigNum.ONE);

        BigNum exponent2 = new BigNum(n);
        exponent2.divide(BigNum.TWO);

        BigNum exponentQ = new BigNum(n);
        exponentQ.divide(q);

        while (true) {
            long generator;
            do {
                generator = randomGenerator.nextLong();
            } while (generator == 0);

            BigNum b = new BigNum(generator, BigNum.BLOCKS - 2);
            b.powerModulo(exponent2, p);

            if (!b.equals(BigNum.ONE)) {
                b = new BigNum(generator, BigNum.BLOCKS - 2);
                b.powerModulo(exponentQ, p);

                if (!b.equals(BigNum.ONE)) {
                    return new Pair(p, new BigNum(generator, BigNum.BLOCKS - 2));
                }
            }
        }
    }

    /**
     * Generates a safe prime (p = 2 * q + 1 where q is prime)
     *
     * @param maximum Maximum q which is used in generating (must be odd).
     * @return Pair (p, q) as described above.
     */
    private Pair generateSafePrime(BigNum maximum) {
        pool.open();

        // small primes used to sieve out candidates which are not prime
        int[] smallPrimes = generateOddPrimes();

        // we need boxed versions of primes to use BigNum class methods
        BigNum[] boxedPrimes = new BigNum[smallPrimes.length];
        for (int i = 0; i < smallPrimes.length; ++i) {
            boxedPrimes[i] = pool.get();
            boxedPrimes[i].initializeFromInt(smallPrimes[i]);
        }

        // initial number to be tested (maximum tested number)
        BigNum start = new BigNum(maximum);

        while (true) {
            // candidates to be tested
            BigNum[] candidates = new BigNum[SIEVE_SIZE];

            // initially we are going to assume all candidates are prime
            boolean[] isPrime = new boolean[SIEVE_SIZE];

            for (int i = 0; i < SIEVE_SIZE; ++i) {
                // we put all candidates into the sieve
                // we could add 2 instead of subtracting it but we want to be
                // sure that our primes will not overflow our maximum which 
                // is used to guarantee that we does not exceed some number of bits
                BigNum toSubtract = new BigNum((SIEVE_SIZE - i - 1) * 2);
                candidates[i] = new BigNum(start);
                candidates[i].subtract(toSubtract);

                isPrime[i] = true;
            }

            // minimal number in the sieve is used to calculate the step in
            // sieving out complex numbers
            BigNum minimum = new BigNum(candidates[0]);

            int counter = 0;
            for (int prime : smallPrimes) {
                // the remainder of first number in the sieve modulo current 
                // small prime is used to determine which number we sieve out
                // in this step
                BigNum remainder = new BigNum(minimum);
                remainder.modulo(boxedPrimes[counter++]);

                // we calculate:
                // minimum % prime = remainder
                // we need to check if there are some k satisfying the
                // condition:
                //    (minimum + 2 * k) % prime = 0
                // unbox the remainder
                int r = (int) remainder.getBlock(BigNum.BLOCKS - 1);

                // find the smallest k which satisfy the above condition
                int currentCandidate = 0;
                while (currentCandidate < SIEVE_SIZE) {
                    if (r == 0) {
                        isPrime[currentCandidate] = false;
                        break;
                    }

                    // now we can try to skip testing some candidates
                    // remainder is less than prime
                    // with each candidate we increase the remainder by 2
                    // we can say that a candidate is complex when we get:
                    //    remainder + 2 * k = m * p
                    // where k and m are some integers
                    // we can take k equal ceil((p - r) / 2)
                    int step = (prime - r) / 2;
                    if ((prime - r) % 2 != 0) {
                        ++step;
                    }

                    currentCandidate += step;
                    r += 2 * step;
                    r %= prime;
                }

                // when some candidate is divisible by current prime we can
                // disqualify some other candidates which are also divisible
                while (currentCandidate < SIEVE_SIZE) {
                    isPrime[currentCandidate] = false;
                    currentCandidate += prime;
                }
            }

            System.out.println("Sieving finished");
            int numbersToCheck = 0;
            for (int i = 0; i < SIEVE_SIZE; ++i) {
                if (isPrime[i]) {
                    ++numbersToCheck;
                }
            }

            System.out.println("Numbers to be checked: " + numbersToCheck);

            for (int i = 0; i < SIEVE_SIZE; ++i) {
                // for candidates which still can be primes we perform
                // Miller-Rabin test
                if (isPrime[i]) {
                    System.out.println("Checking");
                    if (primeTester.isPrime(candidates[i], ACCURACY)) {
                        // no we are almost sure the candidate is prime
                        // the chance it is complex is:
                        // 4^(-ACCURACY)
                        BigNum p = new BigNum(candidates[i]);
                        p.multiply(BigNum.TWO);
                        p.add(BigNum.ONE);
                        if (primeTester.isPrime(p, ACCURACY)) {
                            pool.close();
                            return new Pair(p, new BigNum(candidates[i]));
                        }
                    }
                }
            }

            start = new BigNum(candidates[0]);
            start.subtract(BigNum.TWO);
        }
    }

    /**
     * Generates all odd primes not greater than MAX_GENERATED_PRIME constant.
     *
     * @return All generated odd primes in increasing order.
     */
    private int[] generateOddPrimes() {
        // array tab holds all numbers up to MAX_GENERATED_PRIME constant
        boolean tab[] = new boolean[MAX_GENERATED_PRIME + 1];

        // for each number the value in array indicates if it is a prime number
        tab[0] = false;
        tab[1] = false;
        tab[2] = true;

        // initially we assume that every odd number greater than 2 is prime
        // as algorithm iterates we sieve out complex numbers
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            tab[i] = ((i % 2) == 1);
        }

        // we only need to iterate up to square root from the maximum number
        // to sieve out all complex numbers
        // in every iteration we increase i by 2 because even numbers for sure
        // are complex
        for (int i = 3; i * i <= MAX_GENERATED_PRIME; i += 2) {
            if (tab[i]) {
                // every multiple of i must be a complex number
                for (int j = i + i; j <= MAX_GENERATED_PRIME; j += i) {
                    tab[j] = false;
                }
            }
        }

        // count all generated all primes to allocate an array of appropriate
        // size
        int primesCount = 0;
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            if (tab[i]) {
                ++primesCount;
            }
        }

        // an array for all generated odd primes
        int result[] = new int[primesCount];
        int position = 0;
        for (int i = 3; i <= MAX_GENERATED_PRIME; ++i) {
            if (tab[i]) {
                result[position] = i;
                ++position;
            }
        }

        return result;
    }

    public static PrimeGenerator getInstance() {
        return PrimeSieveHolder.INSTANCE;

    }

    private static class PrimeSieveHolder {

        private static final PrimeGenerator INSTANCE = new PrimeGenerator();
    }
}
